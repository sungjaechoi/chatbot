# 최종 결과 보고: 20260210-유저별-크레딧사용량추적

## 결과 요약

| 항목 | 내용 |
|------|------|
| **작업 ID** | 20260210-유저별-크레딧사용량추적 |
| **시작 일시** | 2026-02-10 |
| **완료 일시** | 2026-02-10 |
| **최종 상태** | ✅ PASS |
| **총 재작업 횟수** | 1회 |

## 완료 조건 충족 여부

| 조건 | 상태 | 비고 |
|------|------|------|
| credit_usage_logs 테이블이 생성되고 RLS가 적용됨 | ✅ 충족 | SELECT만 허용, INSERT/UPDATE/DELETE 의도적 거부. 서버(Admin Client)만 INSERT 가능. |
| 채팅 응답 후 credit_usage_logs에 사용량이 자동 기록됨 | ✅ 충족 | chat route에서 usage 존재 시 non-blocking으로 기록. model_name, prompt_tokens, completion_tokens, session_id, pdf_id, metadata 포함. |
| PDF 임베딩 시에도 사용량이 기록됨 | ✅ 충족 | embedDocuments 반환 타입 변경으로 usage.tokens 수집. action_type='embedding', prompt_tokens에 input tokens 매핑. |
| 사용량 기록 실패 시에도 채팅/임베딩 응답은 정상 반환됨 | ✅ 충족 | logCreditUsage 내부 try-catch + 외부 .catch()로 이중 안전장치. non-blocking fire-and-forget 패턴. |
| get_user_credit_usage_summary RPC로 유저별 집계 조회 가능 | ✅ 충족 | SECURITY DEFINER + auth.uid() 기반 필터링. GET /api/credits/usage 엔드포인트로 호출 가능. |
| 기존 기능(채팅, PDF 업로드 등)에 영향 없음 | ✅ 충족 | ChatResponse 타입 변경 없음. SavePdfResponse 타입 변경 없음. embedText(retriever.ts) 영향 없음. |

## 생성/수정된 파일

### Schema

| 파일 경로 | 변경 유형 | 설명 |
|-----------|-----------|------|
| supabase/schema.sql | modified | credit_usage_logs 테이블(섹션 10), get_user_credit_usage_summary RPC(섹션 11), 인덱스 3개, RLS 정책, 마이그레이션/롤백 SQL 주석, 설계 의도 주석 추가 |

### Backend

| 파일 경로 | 변경 유형 | 설명 |
|-----------|-----------|------|
| src/shared/lib/supabase/credit-service.ts | created | logCreditUsage 유틸 함수. Admin Client로 RLS 우회 INSERT, non-blocking(절대 throw하지 않음). |
| src/shared/lib/langchain/embeddings.ts | modified | embedDocuments 반환 타입을 number[][] → { embeddings: number[][], usage: { tokens: number } }로 변경. |
| src/shared/lib/langchain/rag.ts | modified | executeRAGPipeline 반환값에 model: string 추가. generateAnswer의 LLMResult에서 model을 destructuring. |
| src/app/api/chat/route.ts | modified | RAG 파이프라인에서 model 정보 수신. 8단계 추가: usage 존재 시 logCreditUsage로 사용량 기록 (non-blocking). |
| src/app/api/pdf/[pdfId]/save/route.ts | modified | embedDocuments에서 { embeddings, usage } 수신. logCreditUsage로 임베딩 사용량 기록 (non-blocking). tokens 매핑 주석 추가. |
| src/app/api/credits/usage/route.ts | created | GET /api/credits/usage 엔드포인트. Server Client로 인증 후 get_user_credit_usage_summary RPC 호출, 사용량 집계 반환. |
| src/shared/types/index.ts | modified | CreditUsageSummaryResponse 인터페이스 추가. |

### Frontend

해당 없음

## 주요 변경 사항

### 1. credit_usage_logs 테이블 신규 추가

- 유저별 크레딧(API 토큰) 사용 이력을 저장하는 immutable 로그 테이블
- action_type으로 채팅(chat)과 임베딩(embedding) 구분
- total_tokens는 GENERATED ALWAYS AS 컬럼으로 자동 계산
- RLS: SELECT만 허용, INSERT는 서버(Admin Client, service_role) 전용

### 2. 채팅/임베딩 API에 사용량 기록 로직 추가

- 채팅 완료 시: model_name, prompt_tokens, completion_tokens, session_id, pdf_id, metadata(question, sourcesCount) 기록
- 임베딩 완료 시: model_name, prompt_tokens(=input tokens), pdf_id, metadata(fileName, totalPages, textsCount) 기록
- non-blocking 패턴: 기록 실패가 원래 응답에 영향을 미치지 않음

### 3. 사용량 조회 API 엔드포인트 추가

- GET /api/credits/usage: 인증된 유저의 크레딧 사용량 요약 반환
- get_user_credit_usage_summary RPC 함수 호출
- total_prompt_tokens, total_completion_tokens, total_tokens, total_cost, chat_count, embedding_count 집계

### 4. embedDocuments 반환 타입 개선

- 기존: number[][] (임베딩 벡터만)
- 변경: { embeddings: number[][], usage: { tokens: number } } (usage 정보 포함)
- Vercel AI SDK embedMany의 usage 반환값 활용

## API 변경

| Method | Endpoint | 변경 내용 |
|--------|----------|-----------|
| GET | /api/credits/usage | 신규 추가. 인증된 유저의 크레딧 사용량 요약(토큰 합계, 비용, 채팅/임베딩 횟수) 반환. |

## DB 스키마 변경

### 변경 요약

| 변경 유형 | 대상 | 설명 | 파괴적 변경 |
|-----------|------|------|-------------|
| table_created | credit_usage_logs | 유저별 크레딧 사용량 추적 테이블. action_type(chat/embedding), model_name, prompt_tokens, completion_tokens, total_tokens(자동계산), total_cost, session_id, pdf_id, metadata 컬럼. | 아니오 |
| index_created | idx_credit_usage_logs_* | 유저별 조회, 유저별 최근순 조회, 액션 타입별 필터링 인덱스 3개 추가. | 아니오 |
| rls_added | Users can view own credit usage logs | credit_usage_logs에 SELECT만 허용하는 RLS 정책. INSERT/UPDATE/DELETE는 정책 없음(기본 거부). | 아니오 |
| rpc_created | get_user_credit_usage_summary | 유저별 크레딧 사용량 집계 RPC. SECURITY DEFINER + auth.uid() 필터링. | 아니오 |

### 마이그레이션 SQL

```sql
-- credit_usage_logs 테이블 생성
CREATE TABLE IF NOT EXISTS credit_usage_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  action_type TEXT NOT NULL CHECK (action_type IN ('chat', 'embedding')),
  model_name TEXT,
  prompt_tokens INTEGER DEFAULT 0,
  completion_tokens INTEGER DEFAULT 0,
  total_tokens INTEGER GENERATED ALWAYS AS (prompt_tokens + completion_tokens) STORED,
  total_cost NUMERIC(10, 6) DEFAULT 0,
  session_id UUID REFERENCES chat_sessions(id) ON DELETE SET NULL,
  pdf_id TEXT,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX IF NOT EXISTS idx_credit_usage_logs_user_id ON credit_usage_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_credit_usage_logs_user_created ON credit_usage_logs(user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_credit_usage_logs_action_type ON credit_usage_logs(action_type);
ALTER TABLE credit_usage_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own credit usage logs" ON credit_usage_logs FOR SELECT USING (auth.uid() = user_id);

-- get_user_credit_usage_summary RPC 함수
CREATE OR REPLACE FUNCTION get_user_credit_usage_summary()
RETURNS TABLE (total_prompt_tokens BIGINT, total_completion_tokens BIGINT, total_tokens BIGINT, total_cost NUMERIC, chat_count BIGINT, embedding_count BIGINT)
LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  RETURN QUERY SELECT COALESCE(SUM(cul.prompt_tokens)::BIGINT, 0), COALESCE(SUM(cul.completion_tokens)::BIGINT, 0), COALESCE(SUM(cul.prompt_tokens + cul.completion_tokens)::BIGINT, 0), COALESCE(SUM(cul.total_cost), 0), COUNT(*) FILTER (WHERE cul.action_type = 'chat'), COUNT(*) FILTER (WHERE cul.action_type = 'embedding') FROM credit_usage_logs cul WHERE cul.user_id = auth.uid();
END;
$$;
```

### 롤백 SQL

```sql
-- 롤백: credit_usage_logs 테이블 및 RPC 함수 삭제
DROP FUNCTION IF EXISTS get_user_credit_usage_summary();
DROP TABLE IF EXISTS credit_usage_logs;
```

### 적용 방법

1. Supabase 대시보드 SQL Editor에서 마이그레이션 SQL을 실행합니다.
2. 실행 후 아래 확인사항을 점검합니다.
3. 문제 발생 시 롤백 SQL을 실행합니다.

### 확인사항

- [ ] 마이그레이션 SQL 실행 성공
- [ ] 새 테이블/컬럼이 정상 생성되었는지 확인
- [ ] RLS 정책이 올바르게 적용되었는지 확인
- [ ] RPC 함수가 정상 호출되는지 확인
- [ ] 기존 데이터에 영향 없는지 확인
- [ ] `supabase/schema.sql`이 최신 상태로 업데이트되었는지 확인

## 미해결 사항

| 항목 | 심각도 | 설명 |
|------|--------|------|
| total_cost가 항상 0 | low | Vercel AI SDK streamText 응답에 cost 필드가 없어 total_cost가 항상 0으로 기록됨. 향후 비용 계산 로직 추가 필요. |
| logCreditUsage 이중 에러 처리 | low | logCreditUsage 내부 try-catch와 호출부의 .catch()가 중복. 방어적 코딩이나 리팩토링 가능. |

## 후속 작업 권장

1. total_cost 계산 로직 추가 (모델별 토큰 단가 테이블 또는 Vercel AI Gateway 비용 API 연동)
2. 유저별 사용량 제한(rate limiting) 기능 구현 시 credit_usage_logs 활용 가능
3. 관리자용 전체 사용량 대시보드 구현 시 별도 admin API 추가 고려
4. 사용량 데이터 기반 알림/경고 시스템 (일일 한도 초과 시 알림 등)

---
*생성: Orchestrator | 일시: 2026-02-10*
